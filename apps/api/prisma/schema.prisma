generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Plan {
  free
  pro
  business
}

enum UserRole {
  owner
  admin
  staff
}

enum BookingStatus {
  pending
  confirmed
  cancelled
  rescheduled
  no_show
  completed
}

enum WaitlistStatus {
  waiting
  notified
  booked
  cancelled
}

model Tenant {
  id                     String                  @id @default(cuid())
  name                   String
  slug                   String                  @unique
  plan                   Plan                    @default(free)
  bookingBufferMinutes   Int                     @default(0)
  maxBookingsPerDay      Int?
  maxBookingsPerWeek     Int?
  cancellationNoticeHours Int                    @default(0)
  rescheduleNoticeHours   Int                    @default(0)
  bookingFormFields       Json?
  users                  User[]
  services               Service[]
  staff                  Staff[]
  availabilityRules      AvailabilityRule[]
  availabilityExceptions AvailabilityException[]
  bookings               Booking[]
  waitlistEntries        WaitlistEntry[]
  customers              Customer[]
  auditLogs              AuditLog[]
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
}

model User {
  id           String   @id @default(cuid())
  tenantId     String
  email        String   @unique
  passwordHash String
  role         UserRole @default(owner)
  tenant       Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([tenantId])
}

model Service {
  id              String   @id @default(cuid())
  tenantId        String
  name            String
  durationMinutes Int
  price           Decimal  @db.Decimal(10, 2)
  active          Boolean  @default(true)
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  bookings        Booking[]
  waitlistEntries WaitlistEntry[]
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([tenantId])
}

model Staff {
  id                     String                  @id @default(cuid())
  tenantId               String
  fullName               String
  email                  String
  active                 Boolean                 @default(true)
  tenant                 Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  availabilityRules      AvailabilityRule[]
  availabilityExceptions AvailabilityException[]
  bookings               Booking[]
  waitlistEntries        WaitlistEntry[]
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt

  @@index([tenantId])
  @@unique([tenantId, email])
}

model AvailabilityRule {
  id         String   @id @default(cuid())
  tenantId   String
  staffId    String?
  dayOfWeek  Int
  startTime  String
  endTime    String
  isActive   Boolean  @default(true)
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  staff      Staff?   @relation(fields: [staffId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([tenantId])
  @@index([staffId])
  @@index([tenantId, dayOfWeek, isActive])
}

model AvailabilityException {
  id            String   @id @default(cuid())
  tenantId      String
  staffId       String?
  date          DateTime
  startTime     String?
  endTime       String?
  isUnavailable Boolean  @default(true)
  note          String?
  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  staff         Staff?   @relation(fields: [staffId], references: [id], onDelete: Cascade)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([tenantId])
  @@index([staffId])
  @@index([tenantId, date])
}

model Booking {
  id            String        @id @default(cuid())
  tenantId      String
  customerId    String?
  serviceId     String
  staffId       String
  customerName  String
  customerEmail String
  startAt       DateTime
  endAt         DateTime
  status        BookingStatus @default(confirmed)
  cancelledAt   DateTime?
  cancellationReason String?
  customFields  Json?
  notes         String?
  tenant        Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer      Customer?     @relation(fields: [customerId], references: [id], onDelete: SetNull)
  service       Service       @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  staff         Staff         @relation(fields: [staffId], references: [id], onDelete: Cascade)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@index([tenantId])
  @@index([customerId])
  @@index([staffId])
  @@index([tenantId, startAt])
}

model Customer {
  id            String    @id @default(cuid())
  tenantId      String
  fullName      String
  email         String
  phone         String?
  internalNotes String?
  metadata      Json?
  tenant        Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  bookings      Booking[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([tenantId])
  @@unique([tenantId, email])
}

model AuditLog {
  id          String   @id @default(cuid())
  tenantId    String
  actorUserId String?
  action      String
  entity      String
  entityId    String?
  metadata    Json?
  ip          String?
  userAgent   String?
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@index([tenantId])
  @@index([action])
  @@index([createdAt])
}

model WaitlistEntry {
  id               String        @id @default(cuid())
  tenantId         String
  serviceId        String
  staffId          String
  customerName     String
  customerEmail    String
  preferredStartAt DateTime
  status           WaitlistStatus @default(waiting)
  notes            String?
  notifiedAt       DateTime?
  tenant           Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  service          Service       @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  staff            Staff         @relation(fields: [staffId], references: [id], onDelete: Cascade)
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  @@index([tenantId])
  @@index([staffId])
  @@index([tenantId, status, preferredStartAt])
}
